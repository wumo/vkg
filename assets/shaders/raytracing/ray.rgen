#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

#include "resources.h"
#include "../sampling.h"

layout(location = 0) rayPayloadNV RayPayload prd;

vec3 d(uint x, uint y, vec3 r, vec3 u, vec3 v, vec2 jitter) {
  vec2 p = (vec2(x, y) + jitter) / gl_LaunchSizeNV.xy;
  vec2 c = p * 2.0 - 1.0;
  return normalize(v + c.x * r + c.y * u);
}

void main() {
  const float a = cam.w / cam.h;
  const float f = tan(cam.fov / 2);
  const vec3 r = cam.zNear * a * f * cam.r.xyz;
  const vec3 u = -f * cam.zNear * normalize(cross(cam.r.xyz, cam.v.xyz));
  const vec3 v = cam.zNear * cam.v.xyz;

  vec3 hitValue = vec3(0);

  RayDesc ray;
  ray.rayFlags = gl_RayFlagsOpaqueNV;
  ray.cullMask = 0xFF;
  ray.tmin = 0;
  ray.tmax = cam.zFar;
  ray.sbtRecordOffset = 0;
  ray.sbtRecordStride = 0;
  ray.missIndex = 0;

  for(int smpl = 0; smpl < nbSamples; ++smpl) {
    vec3 result = vec3(0.f);
    prd.attenuation = vec3(1.f);
    prd.done = 0;
    prd.seed =
      tea(gl_LaunchIDNV.y * gl_LaunchSizeNV.x + gl_LaunchIDNV.x, cam.frame + smpl);

    ray.origin = cam.eye.xyz;
    ray.direction = d(
      gl_LaunchIDNV.x, gl_LaunchIDNV.y, r, u, v, smpl == 0 ? vec2(0.5) : rnd2(prd.seed));

    for(int depth = 0; depth < maxDepth; ++depth) {
      trace(tlas, ray, 0);

      result += prd.radiance;

      if(depth == 0) {
      } else {
        ray.cullMask = opaqueMask;
      }

      if(prd.done == 1) break;
      ray.origin = prd.origin;
      ray.direction = prd.direction;
    }
    hitValue += result;
  }

  vec3 hitColor = hitValue / nbSamples;
  imageStore(colorImg, ivec2(gl_LaunchIDNV.xy), vec4(hitColor, 1.f));
}
