#version 450
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : enable
// #extension GL_EXT_debug_printf : enable

#include "../common.h"
layout(constant_id = 0) const uint lx = 1;
layout(constant_id = 1) const uint ly = 1;
layout(constant_id = 2) const uint lz = 1;
layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z_id = 2) in;

layout(push_constant) uniform TotalMeshInstances { uint total; };

layout(set = 0, binding = 0) uniform Frustum { vec4 planes[6]; };
layout(set = 0, binding = 1, scalar) buffer DrawIndirectCMDBuffer {
  VkDrawIndexedIndirectCommand drawCMDs[];
};
layout(set = 0, binding = 2, scalar) buffer OutDrawIndirectCMDBuffer {
  VkDrawIndexedIndirectCommand outDrawCMDs[];
};
layout(set = 0, binding = 3, scalar) buffer OutDrawCountBuffer { uint drawCount; };

layout(set = 1, binding = 0, scalar) readonly buffer MeshesBuffer {
  MeshInstanceUBO meshInstances[];
};
layout(set = 1, binding = 1, scalar) readonly buffer PrimitiveBuffer {
  PrimitiveUBO primitives[];
};
layout(set = 1, binding = 2, std430) readonly buffer TransformBuffer { mat4 matrices[]; };

bool isInFrustum(vec4 p, float radius) {
  p /= p.w;
  for(int i = 0; i < 6; ++i)
    if(dot(planes[i], p) + radius < 0) return false;
  return true;
}

bool frustumIntersectAABB(AABB aabb) { return false; }

void transformAABB(inout AABB aabb, mat4 m) {
  vec3 _min = vec3(m[3]);
  vec3 _max = _min;

  vec3 p = vec3(m[0]);
  vec3 v0 = p * aabb.min.x;
  vec3 v1 = p * aabb.max.x;
  _min += min(v0, v1);
  _max += max(v0, v1);

  p = vec3(m[1]);
  v0 = p * aabb.min.y;
  v1 = p * aabb.max.y;
  _min += min(v0, v1);
  _max += max(v0, v1);

  p = vec3(m[2]);
  v0 = p * aabb.min.z;
  v1 = p * aabb.max.z;
  _min += min(v0, v1);
  _max += max(v0, v1);

  aabb.min = _min;
  aabb.max = _max;
}

void main() {
  uint NX = gl_NumWorkGroups.x * gl_WorkGroupSize.x;
  uint NY = gl_NumWorkGroups.y * gl_WorkGroupSize.y;
  uint id = gl_GlobalInvocationID.z * (NX * NY) + gl_GlobalInvocationID.y * NX +
            gl_GlobalInvocationID.x;

  if(id >= total) return;

  VkDrawIndexedIndirectCommand drawCMD = drawCMDs[id];
  uint inst = drawCMD.firstInstance;
  MeshInstanceUBO mesh = meshInstances[inst];
  mat4 model = matrices[inst];
  if(!mesh.visible) return;
  PrimitiveUBO prim = primitives[mesh.primitive];
  AABB aabb = prim.aabb;
  transformAABB(aabb, model);

  vec3 center = (aabb.min + aabb.max) / 2;
  float radius = length(aabb.max - aabb.min) / 2;
  if(isInFrustum(vec4(center, 1), 0)) {
    uint outIdx = atomicAdd(drawCount, 1);
    drawCMD.instanceCount = 1u;
    outDrawCMDs[outIdx] = drawCMD;
    return;
  }
  if(!isInFrustum(vec4(center, 1), radius)) return;

  uint outIdx = atomicAdd(drawCount, 1);
  drawCMD.instanceCount = 1u;
  outDrawCMDs[outIdx] = drawCMD;
}