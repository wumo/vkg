#version 450
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : enable
// #extension GL_EXT_debug_printf : enable

#include "../common.h"
layout(constant_id = 0) const uint lx = 1;
layout(constant_id = 1) const uint ly = 1;
layout(constant_id = 2) const uint lz = 1;
layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z_id = 2) in;

layout(push_constant) uniform PushConstant {
  uint totalFrustums;
  uint totalMeshInstances;
  uint cmdFrustumStride;
  uint groupStride;
  uint frame;
};

layout(set = 0, binding = 0, scalar) buffer Frustums { Frustum frustums[]; };
layout(set = 0, binding = 1, scalar) readonly buffer MeshesBuffer {
  MeshInstanceUBO meshInstances[];
};
layout(set = 0, binding = 2, scalar) readonly buffer PrimitiveBuffer {
  PrimitiveUBO primitives[];
};
layout(set = 0, binding = 3, std430) readonly buffer TransformBuffer { mat4 matrices[]; };
layout(set = 0, binding = 4, scalar) buffer DrawIndirectCMDBuffer {
  VkDrawIndexedIndirectCommand drawCMDs[];
};
layout(set = 0, binding = 5, scalar) readonly buffer DrawGroupOffsetBuffer {
  uint cmdOffsetPerGroup[];
};
layout(set = 0, binding = 6, scalar) buffer DrawCountBuffer { uint drawCMDCount[]; };

void main() {
  uint NX = gl_NumWorkGroups.x * gl_WorkGroupSize.x;
  uint NY = gl_NumWorkGroups.y * gl_WorkGroupSize.y;
  uint dispatchId = gl_GlobalInvocationID.z * (NX * NY) + gl_GlobalInvocationID.y * NX +
                    gl_GlobalInvocationID.x;
  uint id = dispatchId % totalMeshInstances;
  uint frustumIdx = dispatchId / totalMeshInstances;
  if(frustumIdx >= totalFrustums) return;
  Frustum frustum = frustums[frustumIdx];

  MeshInstanceUBO mesh = meshInstances[id];

  if(!mesh.visible || mesh.drawGroupID == DrawGroupUnknown) return;

  uint primitiveOffset = clamp(frame, 0, mesh.primitiveCount - 1);
  PrimitiveUBO prim = primitives[mesh.primitive + primitiveOffset];
  AABB aabb = prim.aabb;
  mat4 model = matrices[id];
  transformAABB(aabb, model);
  vec3 center = (aabb.min + aabb.max) / 2;
  float radius = length(aabb.max - aabb.min) / 2;
  if(
    isInFrustum(frustum, vec4(center, 1), 0) ||
    isInFrustum(frustum, vec4(center, 1), radius)) {
    VkDrawIndexedIndirectCommand drawCMD;
    drawCMD.firstIndex = prim.index.start;
    drawCMD.indexCount = prim.index.size;
    drawCMD.vertexOffset = int(prim.position.start);
    drawCMD.firstInstance = id;
    drawCMD.instanceCount = 1;

    uint groupID = mesh.drawGroupID;
    uint groupIdx = atomicAdd(drawCMDCount[frustumIdx * groupStride + groupID], 1);
    uint groupOffset = cmdOffsetPerGroup[groupID];
    uint cmdIdx = frustumIdx * cmdFrustumStride + groupOffset + groupIdx;
    drawCMDs[cmdIdx] = drawCMD;
  }
}